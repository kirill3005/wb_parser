Вот готовый файл `CANDIDATES_GUIDE.md`. Скопируй в `configs/recsys/docs/` или в корень репо.

---

# CANDIDATES_GUIDE.md

Подробное объяснение всех генераторов кандидатов: что делают, какие параметры есть, когда и как их использовать. Док опирается на поля из универсального профиля (`_universal.yaml`), но подойдёт и к твоим `full/gate/scout/panic`.

---

## TL;DR

* Сначала **накрываем покрытие (Coverage@K)** за счёт быстрых источников: `pop`, `recent`, `covis`.
* Затем добавляем **структурные** источники (`session_ngram`, `item2vec`, `mf_als`) и **графовые** (`lightgcn`, `graph_ppr`) — они расширяют «радиус» поиска.
* Текст/семантика (`bm25`, `dense_ann`) — опциональные усилители для задач, где названия/жанры важны.
* Размер пула контролируют `quota` у источников и `union.K_union` (или `cutoff:auto`).
* Если времени мало — **panic**: `pop + recent + covis` и сразу в сабмит.

---

## Выход каждого генератора

Каждый источник возвращает таблицу со столбцами минимум:

```
[query_id, item_id, score_<source>, rank_<source>, source="<source_name>"]
```

При объединении (`union`) мы:

* объединяем списки,
* снимаем дубликаты по `item_id` (`dedup_by_item: true`),
* уважаем `quota` (не больше N из каждого источника),
* сортируем по выбранной схеме (например, `-score, item_id`) и/или нормируем per-user.

---

## Общие ручки (работают для всех источников)

```yaml
candidates:
  time_window_days: 60      # сколько дней истории анализируем по умолчанию
  cutoff: "auto"            # "auto" => K_union = max(K, sum(quotas), topK_submit*2)
  K: 200                    # fallback-минимум кандидатов, если нет union
  dedup_by_item: true
  ensure_seen_items: true   # всегда включать собственную историю пользователя
  cold_start:
    fallback: "global_pop"  # когда у запроса нет истории
    K: 200
  union:
    K_union: 800
    tie_break: ["-score", "item_id"]
    per_source_limit: true
    per_query_weights: { ... }  # веса источников для простого бленда без моделей
```

---

## Источники

### 1) POP (глобальная/взвешенная популярность)

**Идея.** Чем чаще и свежее слушают трек, тем выше его шанс попасть в пул.

**Скор.**
[
\text{pop}(i) = \sum_{e \in \text{events}(i)} w(t_{\text{now}} - t_e),
\quad w(\Delta d) = 0.5^{\Delta d / h}
]
где (h =) `half_life_days`.

**Поля**

```yaml
pop:
  enable: true
  windows_days: [7, 30, 60]      # считаем несколько окон
  half_life_days: 7              # эксп. затухание (свежак важнее)
  dislike_penalty: 0.5           # штраф, если у трека много дизлайков
  with_user_recent: true         # легкий персональный сдвиг к недавним у пользователя
  quota: 30
```

**Когда включать.** Всегда. Это твой «страховочный трос» и опора при cold-start.
**Когда крутить.** Если пул устарел — уменьшай `half_life_days` или добавляй короткие окна (7/14). Если «перегиб» в трендинг — убавь вес свежести, добавь `dislike_penalty`.

**Сложность.** Низкая. Считается быстро, подходит для паник-режима.

---

### 2) RECENT (персональная недавняя активность)

**Идея.** Пользователь завтра слушает похожее на то, что слушал вчера.

**Поведение.**

* Берём последние прослушивания пользователя за `days_back`.
* Добавляем «expansion»: новые треки любимых **артистов/жанров**.

**Поля**

```yaml
recent:
  enable: true
  days_back: 30
  expand_artist: true
  expand_genre: true
  quota: 40
```

**Когда включать.** Всегда, если у пользователя есть история.
**Когда крутить.** Мало персонализации → подними `days_back` и включи расширения; слишком «залипает» на одном — уменьшай `days_back` и ограничивай повторы в `rerank`.

**Сложность.** Низкая.

---

### 3) COVIS (co-visitation на сессиях)

**Идея.** Треки, которые часто встречаются рядом в одной сессии, — хорошие соседи.

**Скор.**
[
\text{covis}(i \to j) = \sum_{(i,j) \in \text{session}} \frac{1}{\log(1+\Delta t_{i\to j})} \cdot f(\text{position_gap})
]
(формулы задаются строкой `weight`).

**Поля**

```yaml
covis:
  enable: true
  session_gap_min: 30
  weight: "1/log1p(dt_seconds)"   # либо "1/log1p(position_gap)"
  min_pair_count: 2
  topn_per_item: 200
  quota: 80
```

**Когда включать.** Почти всегда. Отлично добирает соседи и расширяет пул.
**Когда крутить.** Слабое покрытие «послезавтра» → увеличь `topn_per_item` и `quota`. Шум → подними `min_pair_count`.

**Сложность.** Средняя: O(сумма L_s^2), где L_s — длины сессий.

---

### 4) SESSION_NGRAM (n-граммы в сессии)

**Идея.** Последовательные шаблоны поведения: «после A,B часто C».

**Поля**

```yaml
session_ngram:
  enable: true
  n: [2,3]
  weight: "1/log1p(position_gap)"
  quota: 60
```

**Когда включать.** Если пользовательские сессии достаточно длинные и последовательные.
**Сложность.** Средняя.

---

### 5) ITEM2VEC (skip-gram по последовательностям)

**Идея.** Учим эмбеддинги треков на «предложениях» из историй слушания. Косинус — близость.

**Поля**

```yaml
item2vec:
  enable: true
  factors: 64
  window: 20
  min_count: 3
  epochs: 5
  topn_per_item: 120
  quota: 80
```

**Когда включать.** Когда каталог большой и есть устойчивые «соседства» треков.
**Сложность.** Средняя; обучение быстрое, инференс через ANN/точный kNN.

---

### 6) MF_ALS (implicit ALS)

**Идея.** Факторизация user×item (implicit). Берём ближайшие item к профилю пользователя.

**Поля**

```yaml
mf_als:
  enable: true
  factors: 64
  reg: 0.05
  alpha: 10
  epochs: 12
  weight_by: "plays+ratio"   # как строим confidence
  topn_per_user: 200
  quota: 60
```

**Когда включать.** Если много взаимодействий и слаб текст/мета. Хорошо обобщает.
**Сложность.** Средняя/высокая (зависит от размеров); но стабильно и без GPU.

---

### 7) LIGHTGCN

**Идея.** Граф user–item, распространение сигналов через несколько слоёв, обучается на парах.

**Поля**

```yaml
lightgcn:
  enable: true
  layers: 3
  dim: 64
  epochs: 20
  lr: 0.001
  dropout: 0.0
  topn_per_user: 200
  quota: 40
```

**Когда включать.** Есть время/железо, нужно качество на «тонких» вкусах.
**Сложность.** Средняя/высокая; GPU желательно.

---

### 8) GRAPH_PPR (Personalized PageRank)

**Идея.** На графе user–item запускаем Personalized PageRank от пользователя.

**Поля**

```yaml
graph_ppr:
  enable: true
  alpha: 0.15      # вероятность «телепорта» к пользователю
  iters: 10
  topn_per_user: 150
  quota: 40
```

**Когда включать.** Когда есть явный двудольный граф и хочется лёгкого графового «расползания».
**Сложность.** Средняя; итеративные умножения/пуш-апроксимации.

---

### 9) BM25 (текст: названия, артисты, жанры)

**Идея.** Текстовый поиск похожего контента.

**Поля**

```yaml
bm25:
  enable: false
  text_fields: ["track_name","artist_name","track_genres_list"]
  min_df: 3
  ngram_range: [1,2]
  topn_per_user: 200
  quota: 40
```

**Когда включать.** Названия/жанры информативны; хочется ловить редкие, но релевантные треки.
**Сложность.** Низкая/средняя (зависит от корпуса).

---

### 10) DENSE_ANN (семантические эмбеддинги)

**Идея.** Энкодер (Sentence-Tfm и т.п.) → вектор трека. Профиль пользователя = агрегация его векторов. Соседи по косинусу.

**Поля**

```yaml
dense_ann:
  enable: false
  encoder: "sentence-transformers/all-MiniLM-L6-v2"
  topn_per_user: 150
  quota: 30
```

**Когда включать.** Есть GPU/время и текст реально несёт смысл.
**Сложность.** Высокая при построении индекса; запросы быстрые.

---

## Объединение источников (UNION)

**Что делает.** Складывает списки источников, снимает дубликаты, ограничивает доли (`quota`), нормирует/взвешивает по желанию.

**Поля**

```yaml
union:
  K_union: 800                      # итоговый размер пула
  tie_break: ["-score", "item_id"]  # стабильный порядок
  per_source_limit: true            # уважать quota
  per_query_weights:
    covis: 1.0
    pop: 0.4
    session_ngram: 0.8
    item2vec: 0.9
    mf_als: 0.9
    lightgcn: 0.9
    graph_ppr: 0.7
    bm25: 0.6
    dense_ann: 0.7
```

**Зачем веса?** Если ранкера нет, можно собрать финальный `ranked` простым взвешиванием нормированных скоров. В противном случае это служит лишь как «подсказка» при бленде.

---

## Что и когда включать — практические профили

### PANIC (последние 30–40 минут)

* `pop` (короткие окна), `recent` (expand_artist), `covis` (умеренный `topn_per_item`).
* `K_union ≈ 8×K_out`.
* Никаких тяжёлых (item2vec/mf/lightgcn/bm25/dense).
* Сразу сабмит или RRF из трёх источников.

### SCOUT (разведка за ≤30 мин)

* Те же три + маленький `item2vec` (factors=32, epochs=2).
* Проверяем Coverage@K на валидации и повышаем/понижаем `quota`.

### GATE (сбалансированный)

* `pop + recent + covis + session_ngram + item2vec + mf_als`.
* `K_union` порядка 600–1000.
* Ранкера хватает одного (LGBM regression).

### FULL (всё, если железо позволяет)

* Добавить `lightgcn`, `graph_ppr`, `bm25`/`dense_ann`.
* Погонять weight-search/level-2 блендинг.

---

## Тюнинг по симптомам

* **Покрытие низкое (Coverage@K ↓)**
  ↑ `quota` у `recent` и `covis`, ↑ `topn_per_item`, ↑ `K_union`, добавь `session_ngram`.
* **Слишком много трендинга/однообразия**
  ↓ вес `pop` в `per_query_weights`, ↑ `recent.expand_*`, включи `item2vec/mf_als`.
* **Редкие вкусы не ловятся**
  Включи `bm25` и/или `dense_ann`; `graph_ppr` тоже помогает.
* **Память/время упираются**
  Отключи `dense_ann`, уменьши `topn_per_item` у `covis`, `K_union` подожми.

---

## Анти-утечки

* Все агрегаты/популярности/ковизы считаем **только на train-окне**.
* В оффлайне (OOF) — **пересчитывать статистики на трейне каждого фолда**, не «видеть» вал.
* `ensure_seen_items: true` — берём историю пользователя из **прошлого**, не залезаем в будущее.

---

## Контроль качества кандидатов

* Быстрая метрика: **Coverage@K** на валидации (сколько «правильных» треков есть в пуле).
* Полезная псевдо-метрика до ранкера: сумма `target_ratio` по top-K после простого взвешивания источников.

---

## Примеры мини-конфигов

**Минимальный POP-только:**

```yaml
candidates:
  pop:    {enable: true, windows_days: [7,30], half_life_days: 7, quota: 500}
  recent: {enable: false}
  covis:  {enable: false}
  union:  {K_union: 500}
```

**Сбалансированный (gate):**

```yaml
candidates:
  pop:    {enable: true, windows_days: [7,30,60], quota: 30}
  recent: {enable: true, days_back: 30, expand_artist: true, quota: 40}
  covis:  {enable: true, session_gap_min: 30, topn_per_item: 200, quota: 80}
  session_ngram: {enable: true, n: [2,3], quota: 60}
  item2vec: {enable: true, factors: 64, window: 20, epochs: 5, quota: 80}
  mf_als:   {enable: true, factors: 64, epochs: 12, quota: 60}
  union:    {K_union: 800}
```

---

## Частые вопросы

**Можно ли ставить `cutoff:auto` и забыть про `K_union`?**
Да. Тогда размер пула подстроится автоматически от квот и `K_out`.

**Как выбрать `quota`?**
Старт: `pop 30, recent 40, covis 80, session_ngram 60, item2vec 80, mf_als 60`. Дальше смотри Coverage@K и двигаешь.

**Нужно ли нормировать скоры источников перед смешиванием?**
Для простого пред-бленда — желательно (per-user z-score или min-max). В ранкере это уже не критично.

---

Готово. Если хочешь, могу сгенерировать под этот гид точный `full.yaml` и `gate.yaml` с комментами, чтобы «из коробки» было видно, что, где и почему включено.
